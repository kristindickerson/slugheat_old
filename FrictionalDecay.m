%%% ==============================================================================
%%   Purpose: 
%      This function computes equilibrium temperatures for each sensor 
%      iteratively
%%   Last edit:
%       08/11/2023 by Kristin Dickerson, UCSC
%%% ==============================================================================

function [NumberOfFricUsedPoints, ...
        MinimumFricEqTemp, ...
        MinimumFricError, ...
        MinimumFricDelays, ...
        MinimumFricSlope, ...
        HPTooLow, ...
        ShiftedTime, ...
        IndexOfMinimums, ...
        DataTemp, ...
        TimeShifts, ...
        ShiftedTau, ...
        DataFAT, ...
        DataLimits, ...
        b, ...
        a, ...
        RMS...
        ] = FrictionalDecay( ...
        figure_Main, ...
        FricTime, ...
        FricTemp, ...
        NumberOfSensors, ...
        FrictionalDelays, ...
        FricMaxStep, ...
        TimeInc, ...
        Currentk, ...
        HyndmanCoeffs, ...
        SensorRadius, ...
        FricTauMin, ...
        FricTauMax, ...
        SensorsToUse, ...
        loading, ...
        A, ...
        B, ...
        C, ...
        D, ...
        E, ...
        F,...
        ShiftedRelativeDepths)

% ====================================== %
%               COMPUTE                  %
% ====================================== %

% Initialize processing
% ----------------------

load('SlugHeat22.mat', 'Tau00Data', 'FAT00')

NumberOfSensorsUsed = length(SensorsToUse);

DataTime = repmat(FricTime,1,NumberOfSensorsUsed);
DataTemp = NaN*ones(size(FricTemp(:,SensorsToUse)));
HC = HyndmanCoeffs;
Kappa = 1e-6*Currentk(SensorsToUse)./(HC(1) ...
    - HC(2)*Currentk(SensorsToUse) ...
    + HC(3)*Currentk(SensorsToUse).^2);
Kappa = repmat(Kappa,length(FricTime),1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% AF 9/02  If statement added to handle negative Kappa values. These are bogus
%          but they can be created if there are thermistors that don't penetrate,
%          and iteration using these values results in negative conductivities.
%          It would be ideal to modify this later so that negative k values are 
%          are trapped and reset to initial values. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
LowestK=min(min(Kappa));
if LowestK < 0
%    close(loading)
%    uialert(figure_Main, ['\bf Error during iteration! Check the following ' ...
%        'data to ensure program feasibility: ' newline newline ...
%        ' - Some thermistors may not have penetrated. ' 'If so, must remove ' ...
%        'these sensors from data and reprocess.' newline newline ...
%        ' - Timing of events (start and end of penetration, firing of heat ' ...
%        'pulse) may be incorrect. If so, must adjust the timing of these ' ...
%        'events in the command window and reprocess.' newline newline],'ERROR!', 'Icon', ...
%        'warning', 'Interpreter','tex')
%    clc;
%    clf reset;
%    close all hidden;
%    clear variables;
%    more off;
%    echo off all;
%    fclose('all'); 
Currentk(all(Kappa<0))=A + B*ShiftedRelativeDepths(all(Kappa<0)) + C*ShiftedRelativeDepths(all(Kappa<0)).^2 ...
                           + D*exp(E*ShiftedRelativeDepths(all(Kappa<0))) + F*log10(ShiftedRelativeDepths(all(Kappa<0)));
Kappa = 1e-6*Currentk(SensorsToUse)./(HC(1) ...
    - HC(2)*Currentk(SensorsToUse) ...
    + HC(3)*Currentk(SensorsToUse).^2);
Kappa = repmat(Kappa,length(FricTime),1);
end
%
DataTau = Kappa.*DataTime/SensorRadius.^2;
%Tau00Index = 1:Tau00Data(3)/Tau00Data(2);

% Truncate Data to selected dimensionless time (Tau) window
% ------------------------------------------------------------

[i,j] = find(DataTau > FricTauMin & DataTau < FricTauMax);
DataTemp(i,j) = FricTemp(i,SensorsToUse(j)'); 

% Compute time shifts
% -------------------

TimeShifts = repmat(FrictionalDelays(SensorsToUse), [FricMaxStep 1]) ...
    + repmat(TimeInc*(1:FricMaxStep)', [1 NumberOfSensorsUsed]);

ShiftedTime = repmat(FrictionalDelays(SensorsToUse),[length(FricTime) 1 FricMaxStep]) ...
    + repmat(FricTime,[1 NumberOfSensorsUsed FricMaxStep]) ...
    + repmat(permute(TimeInc*(1:FricMaxStep),[3 1 2]),[length(FricTime) NumberOfSensorsUsed 1]);

% Compute dimensionless time (Tau) Data
% ---------------------------------------

KappaMatrix = repmat(Kappa,[1 1 FricMaxStep]);
ShiftedTau = KappaMatrix.*ShiftedTime/SensorRadius^2;
ShiftedTauIndex = round(ShiftedTau/Tau00Data(2));

ShiftedTauIndex(ShiftedTauIndex > Tau00Data(3)/Tau00Data(2)) = length(FAT00) + 1;
ShiftedTauIndex(ShiftedTauIndex < 1) = length(FAT00) + 2;
FAT00(end+1) = 9;   
FAT00(end+1) = NaN; 

try
    DataFAT = FAT00(ShiftedTauIndex);
catch
    close(loading)
    uialert(figure_Main, ['\bf Error during iteration! Check the following ' ...
        'data to ensure program feasibility: ' newline newline ...
        ' - Some thermistors may not have penetrated. ' 'If so, must remove ' ...
        'these sensors from data and reprocess.' newline newline ...
        ' - Timing of events (start and end of penetration, firing of heat ' ...
        'pulse) may be incorrect. If so, must adjust the timing of these ' ...
        'events in the command window and reprocess.' newline newline],'ERROR!', 'Icon', ...
        'warning', 'Interpreter','tex')
    clc;
    clf reset;
    close all hidden;
    clear variables;
    more off;
    echo off all;
    fclose('all'); 
    return
end

iDF = find(DataFAT>8);
DataFAT(iDF) = 1./(4*ShiftedTau(iDF))-1./(8*ShiftedTau(iDF).^2);
DataTemp = repmat(DataTemp,[1 1 FricMaxStep]);

% Compute chi-square fits
% -----------------------

[ix,~] = find(~isnan(DataFAT));
[iy,~] = find(~isnan(DataTemp));

DataLimits = [max([min(ix) min(iy)]) min([max(ix) max(iy)])];
NumberOfFricUsedPoints = 1+diff(DataLimits);
clear ix iy jx jy

X = reshape(DataFAT(DataLimits(1):DataLimits(2),:,:), ...
    [NumberOfFricUsedPoints NumberOfSensorsUsed*FricMaxStep]);
Y = reshape(DataTemp(DataLimits(1):DataLimits(2),:,:), ...
    [NumberOfFricUsedPoints NumberOfSensorsUsed*FricMaxStep]);

% If one or more sensors is completely out of tau range, all
% ShiftedTaunIndex will be NaN - this causes code to break

try
    [a,b,~,~,Chi2] = ChiSquaredFit(X,Y);
catch
    uialert(figure_Main, ['\bfError! Program failure. Check the following data to ensure program feasibility:' newline newline ...
        '- Ensure bottom water is correct' newline newline ...
        '- Check that sensors all have measurements ' ...
        'measurements in the required \tau range. Sensors can often be out of the required \tau range when ' ...
        'thermal conductivity values are too low. For heat flow analysis, check heat pulse power. ' ...
        'Heat pulse power might be too low. ' ...
        'If this is the case, you must raise power or ignore heat pulse reduction. ' ...
        'For sensitivity analysis, check minimum thermal conductivity values ' ...
        'for each sensor. Your minimum may be too low.' newline],...
        'ERROR! CHECK DATA', ...
        'Icon','error', 'Interpreter','tex')
    HPTooLow = 1;
    return
end
clear X Y

a = reshape(a,[NumberOfSensorsUsed FricMaxStep]);
b = reshape(b,[NumberOfSensorsUsed FricMaxStep]);
%Sigmaa = reshape(Sigmaa,[NumberOfSensorsUsed FricMaxStep]);
%Sigmab = reshape(Sigmab,[NumberOfSensorsUsed FricMaxStep]);

Chi2 = reshape(Chi2,[NumberOfSensorsUsed FricMaxStep]);
RMS = sqrt(Chi2/(NumberOfFricUsedPoints/2));

% Compute Errors and Standard deviation
% -------------------------------------

MinimumFricError = NaN*ones(NumberOfSensors,1);
MinimumFricDelays = NaN*ones(NumberOfSensors,1);
MinimumFricEqTemp = NaN*ones(NumberOfSensors,1);
MinimumFricSlope = NaN*ones(NumberOfSensors,1);

[Minimums,IndexOfMinimums] = min(2*RMS,[],2);
MinimumFricError(SensorsToUse) = Minimums;
MinimumFricDelays(SensorsToUse) = diag(TimeShifts(IndexOfMinimums,:));    
MinimumFricEqTemp(SensorsToUse) = diag(a(:,IndexOfMinimums));
MinimumFricSlope(SensorsToUse) = diag(b(:,IndexOfMinimums));

% If one or more sensors is completely out of tau range, all
% ShiftedTaunIndex will be NaN - this causes code to break

if any(all(isnan(DataTemp)))
   % whichsens      = find(all(all(isnan(DataTemp)),3));
    uialert(figure_Main, ['\bfError! Program failure. Check the following data to ensure program feasibility:' newline newline ...
        '- Ensure bottom water is correct' newline newline ...
        '- Check that sensors all have measurements ' ...
        'measurements in the required \tau range. Sensors can often be out of the required \tau range when ' ...
        'thermal conductivity values are too low. For heat flow analysis, check heat pulse power. ' ...
        'Heat pulse power might be too low. ' ...
        'If this is the case, you must raise power or ignore heat pulse reduction. ' ...
        'For sensitivity analysis, check minimum thermal conductivity values ' ...
        'for each sensor. Your minimum may be too low.' newline],...
        'ERROR! CHECK DATA', ...
        'Icon','error', 'Interpreter','tex')
    HPTooLow = 1;
    return
else
    HPTooLow = 0;
end  

        


